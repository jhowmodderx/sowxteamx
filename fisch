local PreloadConstants = {
	PlaceVersionSupport = 4000,
	BypassVersion = "V3",
}

local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/jhowmodderxxxx/haxstore/refs/heads/main/savemanagerhax"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/jhowmodderxxxx/haxstore/refs/heads/main/interface"))()

local Window = Fluent:CreateWindow({
    Title = "SOWxTEAM",
    SubTitle = "By RodrigoGTyx | FISCH | SCRIPT ATUALIZADO DIA 25/08/25",
    TabWidth = 160,
    Size = UDim2.fromOffset(520, 350),
    Acrylic = false,
    Theme = "Amethyst",
    MinimizeKey = Enum.KeyCode.LeftAlt
})


local DeviceType = game:GetService("UserInputService").TouchEnabled and "Mobile" or "PC"

local UserInputService = game:GetService("UserInputService")
local Player = game.Players.LocalPlayer
local PlayerGui = Player:WaitForChild("PlayerGui")

local ClickButton = Instance.new("ScreenGui")
ClickButton.Parent = PlayerGui

local MainFrame = Instance.new("Frame")
MainFrame.Name = "LogoButton"
MainFrame.Parent = ClickButton
MainFrame.AnchorPoint = Vector2.new(1, 0)
MainFrame.BackgroundTransparency = 0.8
MainFrame.BackgroundColor3 = Color3.fromRGB(38, 38, 38)
MainFrame.BorderSizePixel = 0
MainFrame.Position = UDim2.new(1, -60, 0, 10)
MainFrame.Size = UDim2.new(0, 45, 0, 45)

local UICorner = Instance.new("UICorner")
UICorner.Parent = MainFrame

local TextButton = Instance.new("TextButton")
TextButton.Parent = MainFrame
TextButton.BackgroundColor3 = Color3.fromRGB(0, 255, 255)
TextButton.BackgroundTransparency = 1
TextButton.BorderSizePixel = 0
TextButton.Size = UDim2.new(1, 0, 1, 0)
TextButton.Text = ""  -- Oculta o texto para mostrar só o ícone
TextButton.TextColor3 = Color3.fromRGB(170, 0, 255)
TextButton.TextSize = 14
TextButton.AutoButtonColor = false

local ImageLabel = Instance.new("ImageLabel")
ImageLabel.Parent = TextButton
ImageLabel.AnchorPoint = Vector2.new(0.5, 0.5)
ImageLabel.BackgroundTransparency = 1
ImageLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
ImageLabel.Size = UDim2.new(1, 20, 1, 20)  -- aumentei aqui
ImageLabel.Image = "rbxassetid://125930606242191"
ImageLabel.ZIndex = 1



task.wait(0.1) -- Garante que a UI está pronta

-- Adiciona a logo grande no fundo roxo vazio
local Logo = Instance.new("ImageLabel")
Logo.Name = "CustomLogo"
Logo.Image = "rbxassetid://125930606242191"
Logo.BackgroundTransparency = 1
Logo.Size = UDim2.new(0, 120, 0, 120)                  -- LOGO grande! Ajuste aqui se quiser maior/menor
Logo.Position = UDim2.new(0, 15, 1, -140)  -- um pouco mais para a esquerda


Logo.ZIndex = 10

-- Logo redonda
local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(1, 0)
UICorner.Parent = Logo

-- Insere no frame principal da UI Fluent
Logo.Parent = Window.Root   -- Se o fundo roxo for outro frame, substitua por Window.ContainerHolder ou similar


TextButton.ZIndex = 2

local ModMenu = Instance.new("Frame")
ModMenu.Name = "ModMenu"
ModMenu.Parent = PlayerGui
ModMenu.AnchorPoint = Vector2.new(0.5, 0.5)
ModMenu.BackgroundTransparency = 0.8
ModMenu.BackgroundColor3 = Color3.fromRGB(38, 38, 38)
ModMenu.BorderSizePixel = 0
ModMenu.Position = UDim2.new(0.5, 0, 0.5, 0)
ModMenu.Size = UDim2.new(0, 200, 0, 300)
ModMenu.Visible = false

local UICorner_2 = Instance.new("UICorner")
UICorner_2.Parent = ModMenu

TextButton.MouseButton1Click:Connect(function()
    ModMenu.Visible = not ModMenu.Visible
end)

if DeviceType == "Mobile" then
    MainFrame.Position = UDim2.new(1, -60, 0, 10)
else
    MainFrame.Position = UDim2.new(1, -120, 0, 10)
end

local dragging, dragInput, dragStart, startPos

local function update(input)
    local delta = input.Position - dragStart
    MainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end

MainFrame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = MainFrame.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

MainFrame.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        update(input)
    end
end)

TextButton.MouseButton1Click:Connect(function()
    game:GetService("VirtualInputManager"):SendKeyEvent(true, "LeftAlt", false, game)
    game:GetService("VirtualInputManager"):SendKeyEvent(false, "LeftAlt", false, game)
end)

-- Criando as Tabs
local MainTab = Window:AddTab({ Title = "Auto Farm", Icon = "settings" })
local TeleportTab = Window:AddTab({ Title = "Teleportes", Icon = "navigation" })
local PlayerTab = Window:AddTab({ Title = "Player", Icon = "user" })
local MiscTab = Window:AddTab({ Title = "Outros", Icon = "settings" })

-- Configurações
local Settings = {
    AutoCast = false,
    AutoShake = false,
    AutoReel = false,
    FreezePlayer = false,
    WalkOnWater = false,
    NoClip = false,
    FishRadar = false,
    GPS = false,
    HideUI = false,
    AntiAFK = false,
    CastMode = "Legit",
    ShakeMode = "Navigation",
    ReelMode = "Blatant",
    WalkZone = "Ocean"
}

-- Serviços
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local CollectionService = game:GetService("CollectionService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- Variáveis de controle
local AntiAFKConnection
local ActivateFly, AlrActivatedFlyPC = false, false


-- Flying Variables
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local IYMouse = Players.LocalPlayer:GetMouse()
local FLYING = false
local QEfly = true
local iyflyspeed = 1
local vehicleflyspeed = 1

-- Funções principais
local function AutoCast()
    if Settings.AutoCast and LocalPlayer.Character then
        local tool = LocalPlayer.Character:FindFirstChildOfClass("Tool")
        if tool and not tool:FindFirstChild("bobber") then
            if Settings.CastMode == "Legit" then
                game:GetService("VirtualInputManager"):SendMouseButtonEvent(0, 0, 0, true, LocalPlayer, 0)
                task.wait(0.5)
                game:GetService("VirtualInputManager"):SendMouseButtonEvent(0, 0, 0, false, LocalPlayer, 0)
            else
                tool.events.cast:FireServer(math.random(90, 99))
            end
        end
    end
end

local function AutoShake()
    if Settings.AutoShake then
        local shakeui = LocalPlayer.PlayerGui:FindFirstChild("shakeui")
        if shakeui then
            local button = shakeui:FindFirstChild("safezone"):FindFirstChild("button")
            if button then
                if Settings.ShakeMode == "Navigation" then
                    game:GetService("GuiService").SelectedObject = button
                    task.wait(0.1)
                    game:GetService("VirtualInputManager"):SendKeyEvent(true, Enum.KeyCode.Return, false, game)
                    task.wait(0.1)
                    game:GetService("VirtualInputManager"):SendKeyEvent(false, Enum.KeyCode.Return, false, game)
                else
                    game:GetService("VirtualInputManager"):SendMouseButtonEvent(
                        button.AbsolutePosition.X + button.AbsoluteSize.X/2,
                        button.AbsolutePosition.Y + button.AbsoluteSize.Y/2,
                        0, true, LocalPlayer, 0
                    )
                    task.wait(0.1)
                    game:GetService("VirtualInputManager"):SendMouseButtonEvent(
                        button.AbsolutePosition.X + button.AbsoluteSize.X/2,
                        button.AbsolutePosition.Y + button.AbsoluteSize.Y/2,
                        0, false, LocalPlayer, 0
                    )
                end
            end
        end
    end
end

local function AutoReel()
    if Settings.AutoReel then
        local reel = LocalPlayer.PlayerGui:FindFirstChild("reel")
        if reel then
            local playerbar = reel:FindFirstChild("bar"):FindFirstChild("playerbar")
            local fish = reel:FindFirstChild("bar"):FindFirstChild("fish")
            if playerbar and fish then
                if Settings.ReelMode == "Legit" then
                    playerbar.Position = fish.Position
                else
                    ReplicatedStorage.events.reelfinished:FireServer(100, false)
                end
            end
        end
    end
end

local function UpdateFishRadar()
    for _, v in ipairs(CollectionService:GetTagged("radarTag")) do
        if v:IsA("BillboardGui") or v:IsA("SurfaceGui") then
            v.Enabled = Settings.FishRadar
        end
    end
end


-- Função para atualizar lista de jogadores
local function UpdatePlayerList()
    local playerList = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(playerList, player.Name)
        end
    end
    return playerList
end

-- ABA: FARM AUTOMATICO
local AutoCastToggle = MainTab:AddToggle("AutoCast", {
    Title = "AUTO CAST",
    Default = false
})

AutoCastToggle:OnChanged(function(value)
    Settings.AutoCast = value
    spawn(function()
        while Settings.AutoCast do
            AutoCast()
            task.wait(1)
        end
    end)
end)

local CastModeDropdown = MainTab:AddDropdown("CastMode", {
    Title = "MODO CAST",
    Values = {"Legit", "Blatant"},
    Multi = false,
    Default = "Legit",
})

CastModeDropdown:OnChanged(function(value)
    Settings.CastMode = value
end)

local AutoShakeToggle = MainTab:AddToggle("AutoShake", {
    Title = "AUTO SHAKE",
    Default = false
})

AutoShakeToggle:OnChanged(function(value)
    Settings.AutoShake = value
    spawn(function()
        while Settings.AutoShake do
            AutoShake()
            task.wait()
        end
    end)
end)

local ShakeModeDropdown = MainTab:AddDropdown("ShakeMode", {
    Title = "MODO SHAKE",
    Values = {"Navigation", "Mouse"},
    Multi = false,
    Default = "Navigation",
})

ShakeModeDropdown:OnChanged(function(value)
    Settings.ShakeMode = value
end)

local AutoReelToggle = MainTab:AddToggle("AutoReel", {
    Title = "AUTO REEL",
    Default = false
})

AutoReelToggle:OnChanged(function(value)
    Settings.AutoReel = value
    spawn(function()
        while Settings.AutoReel do
            AutoReel()
            task.wait()
        end
    end)
end)

local ReelModeDropdown = MainTab:AddDropdown("ReelMode", {
    Title = "MODO REEL",
    Values = {"Legit", "Blatant"},
    Multi = false,
    Default = "Blatant",
})

ReelModeDropdown:OnChanged(function(value)
    Settings.ReelMode = value
end)

-- ABA: TELEPORTES
local farmSpots = {
    {"LOCAL #1 (ÓTIMO)", CFrame.new(5802.14, 135.30, 403.35)},
    {"LOCAL #2 (ÓTIMO)", CFrame.new(-3842.70, 133.25, 340.56)},
    {"LOCAL #3 (ÓTIMO)", CFrame.new(-2024.93, 130.18, 557.97)},
    {"LOCAL #4 (ÓTIMO)", CFrame.new(-3844.12, -563.34, 1068.31)}
}

-- Supondo que LocalPlayer seja uma variável global ou já definida
local player = game.Players.LocalPlayer -- Garantindo que estamos pegando o jogador corretamente
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

-- Criando uma tabela apenas com os nomes dos locais para o dropdown
local farmSpotsNames = {}
for _, spot in ipairs(farmSpots) do
    table.insert(farmSpotsNames, spot[1])
end

-- Adicionando o Dropdown para escolha do local
TeleportTab:AddDropdown("farmSpotsDropdown", {
    Title = "Locais de Farm",
    Values = farmSpotsNames,
    Multi = false,  -- Um único local pode ser selecionado
    Default = 1,  -- O primeiro local será selecionado por padrão
    Callback = function(selectedValue)
        -- Encontrando o CFrame baseado na escolha do dropdown
        local selectedSpot
        for _, spot in ipairs(farmSpots) do
            if spot[1] == selectedValue then
                selectedSpot = spot[2]
                break
            end
        end

        -- Teleportando para o local selecionado
        if selectedSpot then
            pcall(function()
                humanoidRootPart.CFrame = selectedSpot
                Fluent:Notify({
                    Title = "Teleporte",
                    Content = "Teleportado para " .. selectedValue,
                    Duration = 3
                })
            end)
        end
    end
})


TeleportTab:AddButton({
    Title = "JACK MARROW",
    Description = "Teleportar para Jack Marrow",
    Callback = function()
        pcall(function()
            LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-2824.36, 214.31, 1518.13)
            Fluent:Notify({
                Title = "Teleporte",
                Content = "Teleportado para Jack Marrow",
                Duration = 3
            })
        end)
    end
})

TeleportTab:AddButton({
    Title = "REPARAR MAPA",
    Description = "Reparar mapa do tesouro",
    Callback = function()
        pcall(function()
            for _, v in pairs(LocalPlayer.Backpack:GetChildren()) do 
                if v.Name == "Treasure Map" then
                    LocalPlayer.Character.Humanoid:EquipTool(v)
                    workspace.world.npcs["Jack Marrow"].treasure.repairmap:InvokeServer()
                    Fluent:Notify({
                        Title = "Mapa",
                        Content = "Mapa reparado com sucesso!",
                        Duration = 3
                    })
                    break
                end
            end
        end)
    end
})



-- 📦 VENDER ITENS OU PEIXES
MainTab:AddSection("Vender Itens ou Peixes")

-- Dropdown para selecionar o tipo de venda
local sellOptions = {"Vender Tudo", "Vender Peixes (Mão)"}
local selectedOption = sellOptions[1]  -- Definindo a opção inicial como "Vender Tudo"

local sellDropdown = MainTab:AddDropdown("SellDropdown", {
    Title = "Escolha o tipo de venda",
    Values = sellOptions,
    Multi = false,
    Default = 1,
})

-- Atualiza a variável selectedOption quando o dropdown é alterado
sellDropdown:OnChanged(function(v)
    selectedOption = v
end)

-- Botão para realizar a venda com base na opção selecionada
MainTab:AddButton({
    Title = "Vender Seleção",
    Description = "Vender de acordo com a opção selecionada",
    Callback = function()
        pcall(function()
            if selectedOption == "Vender Tudo" then
                ReplicatedStorage.events.SellAll:InvokeServer()
                Fluent:Notify({
                    Title = "Venda",
                    Content = "Inventário vendido!",
                    Duration = 3
                })
            elseif selectedOption == "Vender Peixes (Mão)" then
                ReplicatedStorage.events.Sell:InvokeServer()
                Fluent:Notify({
                    Title = "Venda",
                    Content = "Peixes vendidos!",
                    Duration = 3
                })
            end
        end)
    end
})



-- Teleporte para Jogadores
TeleportTab:AddSection("TELEPORTE PARA JOGADORES")

local PlayerDropdown = TeleportTab:AddDropdown("PlayerTeleport", {
    Title = "SELECIONE O JOGADOR",
    Values = UpdatePlayerList(),
    Multi = false,
    Default = nil,
})

PlayerDropdown:OnChanged(function(selected)
    if selected then
        local player = Players:FindFirstChild(selected)
        if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            pcall(function()
                LocalPlayer.Character.HumanoidRootPart.CFrame = player.Character.HumanoidRootPart.CFrame
                Fluent:Notify({
                    Title = "Teleporte",
                    Content = "Teleportado para " .. player.Name,
                    Duration = 3
                })
            end)
        end
    end
end)

TeleportTab:AddButton({
    Title = "🔄 ATUALIZAR LISTA",
    Description = "Atualizar lista de jogadores",
    Callback = function()
        PlayerDropdown:SetValues(UpdatePlayerList())
        Fluent:Notify({
            Title = "Atualização",
            Content = "Lista de jogadores atualizada!",
            Duration = 2
        })
    end
})

local InfiniteJumpToggle = PlayerTab:AddToggle("Infinite Jump Toggle", {
    Title = "PULO INFINITO",
    Default = false,
    Callback = function(Value)
        ActivateInfiniteJump = Value
        while ActivateInfiniteJump do
            local plr = game:GetService('Players').LocalPlayer
            local m = plr:GetMouse()
            m.KeyDown:connect(function(k)
                if ActivateInfiniteJump then
                    if k:byte() == 32 then
                        local humanoid = game:GetService'Players'.LocalPlayer.Character:FindFirstChildOfClass('Humanoid')
                        humanoid:ChangeState('Jumping')
                        wait()
                        humanoid:ChangeState('Seated')
                    end
                end
            end)
            wait(0.1)
        end
    end
})

-- ABA: JOGADOR
local FreezeToggle = PlayerTab:AddToggle("FreezePlayer", {
    Title = "CONGELAR JOGADOR",
    Default = false
})

FreezeToggle:OnChanged(function(value)
    Settings.FreezePlayer = value
    if value then
        local root = LocalPlayer.Character.HumanoidRootPart
        local originalPos = root.CFrame
        spawn(function()
            while Settings.FreezePlayer do
                root.CFrame = originalPos
                task.wait()
            end
        end)
    end
end)

local WalkOnWaterToggle = PlayerTab:AddToggle("WalkOnWater", {
    Title = "ANDAR NA ÁGUA",
    Default = false
})

WalkOnWaterToggle:OnChanged(function(value)
    Settings.WalkOnWater = value
    for _, zone in ipairs(workspace.zones.fishing:GetChildren()) do
        if zone.Name == Settings.WalkZone or (Settings.WalkZone == "Ocean" and zone.Name == "Deep Ocean") then
            zone.CanCollide = value
        end
    end
end)

local WalkZoneDropdown = PlayerTab:AddDropdown("WalkZone", {
    Title = "ZONA DE ÁGUA",
    Values = {"Ocean", "Desolate Deep", "The Depths"},
    Multi = false,
    Default = "Ocean",
})

WalkZoneDropdown:OnChanged(function(value)
    Settings.WalkZone = value
end)

local NoClipToggle = PlayerTab:AddToggle("NoClip", {
    Title = "WALLHACK (NOCLIP)",
    Default = false
})

NoClipToggle:OnChanged(function(value)
    Settings.NoClip = value
    if value then
        RunService.Stepped:Connect(function()
            if Settings.NoClip and LocalPlayer.Character then
                for _, part in ipairs(LocalPlayer.Character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
            end
        end)
    end
end)

-- ABA: OUTROS
local FishRadarToggle = MiscTab:AddToggle("FishRadar", {
    Title = "RADAR DE PEIXES",
    Default = false
})

FishRadarToggle:OnChanged(function(value)
    Settings.FishRadar = value
    UpdateFishRadar()
end)

local HideUIToggle = MiscTab:AddToggle("HideUI", {
    Title = "OCULTAR UI",
    Default = false
})

local FlySpeedSlider = PlayerTab:AddSlider("Velocidade do Voo", {
    Title = "VELOCIDADE DE VOO",
    Default = 1,
    Min = 0,
    Max = 10,
    Rounding = 1,
    Callback = function(Value)
        iyflyspeed = Value
    end
})

local FlyToggle = PlayerTab:AddToggle("Fly", {
    Title = "VOAR",
    Default = false,
    Callback = function(Value)
        ActivateFly = Value
        task.spawn(function()
            if not FLYING and ActivateFly then
                if UserInputService.TouchEnabled then
                    MobileFly()
                else
                    task.spawn(function()
                        if not AlrActivatedFlyPC then 
                            AlrActivatedFlyPC = true
                            Fluent:Notify({
                                Title = "Fly Controls",
                                Content = "Aperte F para ativar e desativar o fly",
                                Duration = 5
                            })
                        end
                    end)
                    NOFLY()
                    wait()
                    sFLY()
                end
            elseif FLYING and not ActivateFly then
                if UserInputService.TouchEnabled then
                    UnMobileFly()
                else
                    NOFLY()
                end
            end
        end)
    end
})


-- Flying Functions
local function sFLY(vfly)
    repeat wait() until Players.LocalPlayer and Players.LocalPlayer.Character and Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart") and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    repeat wait() until IYMouse
    if flyKeyDown or flyKeyUp then flyKeyDown:Disconnect() flyKeyUp:Disconnect() end

    local T = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
    local CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
    local lCONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
    local SPEED = 0
    local function FLY()
        FLYING = true
        local BG = Instance.new('BodyGyro')
        local BV = Instance.new('BodyVelocity')
        BG.P = 9e4
        BG.Parent = T
        BV.Parent = T
        BG.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
        BG.CFrame = T.CFrame
        BV.Velocity = Vector3.new(0, 0, 0)
        BV.MaxForce = Vector3.new(9e9, 9e9, 9e9)
        
        task.spawn(function()
            repeat wait()
                if not vfly and Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
                    Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = true
                end
                if CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0 then
                    SPEED = 50
                elseif not (CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0) and SPEED ~= 0 then
                    SPEED = 0
                end
                if (CONTROL.L + CONTROL.R) ~= 0 or (CONTROL.F + CONTROL.B) ~= 0 or (CONTROL.Q + CONTROL.E) ~= 0 then
                    BV.Velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (CONTROL.F + CONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(CONTROL.L + CONTROL.R, (CONTROL.F + CONTROL.B + CONTROL.Q + CONTROL.E) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
                    lCONTROL = {F = CONTROL.F, B = CONTROL.B, L = CONTROL.L, R = CONTROL.R}
                elseif (CONTROL.L + CONTROL.R) == 0 and (CONTROL.F + CONTROL.B) == 0 and (CONTROL.Q + CONTROL.E) == 0 and SPEED ~= 0 then
                    BV.Velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (lCONTROL.F + lCONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(lCONTROL.L + lCONTROL.R, (lCONTROL.F + lCONTROL.B + CONTROL.Q + CONTROL.E) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
                else
                    BV.Velocity = Vector3.new(0, 0, 0)
                end
                BG.CFrame = workspace.CurrentCamera.CoordinateFrame
            until not FLYING
            CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
            lCONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
            SPEED = 0
            BG:Destroy()
            BV:Destroy()
            if Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
                Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = false
            end
        end)
    end
    
    flyKeyDown = IYMouse.KeyDown:Connect(function(KEY)
        if KEY:lower() == 'w' then
            CONTROL.F = (vfly and vehicleflyspeed or iyflyspeed)
        elseif KEY:lower() == 's' then
            CONTROL.B = - (vfly and vehicleflyspeed or iyflyspeed)
        elseif KEY:lower() == 'a' then
            CONTROL.L = - (vfly and vehicleflyspeed or iyflyspeed)
        elseif KEY:lower() == 'd' then 
            CONTROL.R = (vfly and vehicleflyspeed or iyflyspeed)
        elseif QEfly and KEY:lower() == 'e' then
            CONTROL.Q = (vfly and vehicleflyspeed or iyflyspeed)*2
        elseif QEfly and KEY:lower() == 'q' then
            CONTROL.E = -(vfly and vehicleflyspeed or iyflyspeed)*2
        end
        pcall(function() workspace.CurrentCamera.CameraType = Enum.CameraType.Track end)
    end)
    
    flyKeyUp = IYMouse.KeyUp:Connect(function(KEY)
        if KEY:lower() == 'w' then
            CONTROL.F = 0
        elseif KEY:lower() == 's' then
            CONTROL.B = 0
        elseif KEY:lower() == 'a' then
            CONTROL.L = 0
        elseif KEY:lower() == 'd' then
            CONTROL.R = 0
        elseif KEY:lower() == 'e' then
            CONTROL.Q = 0
        elseif KEY:lower() == 'q' then
            CONTROL.E = 0
        end
    end)
    FLY()
end


local function NOFLY()
    FLYING = false
    if flyKeyDown or flyKeyUp then flyKeyDown:Disconnect() flyKeyUp:Disconnect() end
    if Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
        Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = false
    end
    pcall(function() workspace.CurrentCamera.CameraType = Enum.CameraType.Custom end)
end

local velocityHandlerName = "BodyVelocity"
local gyroHandlerName = "BodyGyro"
local mfly1, mfly2

local function UnMobileFly()
    pcall(function()
        FLYING = false
        local root = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
        root:FindFirstChild(velocityHandlerName):Destroy()
        root:FindFirstChild(gyroHandlerName):Destroy()
        Players.LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid").PlatformStand = false
        mfly1:Disconnect()
        mfly2:Disconnect()
    end)
end

local function MobileFly()
    UnMobileFly()
    FLYING = true

    local root = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
    local camera = workspace.CurrentCamera
    local v3none = Vector3.new()
    local v3zero = Vector3.new(0, 0, 0)
    local v3inf = Vector3.new(9e9, 9e9, 9e9)

    local controlModule = require(Players.LocalPlayer.PlayerScripts:WaitForChild("PlayerModule"):WaitForChild("ControlModule"))
    local bv = Instance.new("BodyVelocity")
    bv.Name = velocityHandlerName
    bv.Parent = root
    bv.MaxForce = v3zero
    bv.Velocity = v3zero

    local bg = Instance.new("BodyGyro")
    bg.Name = gyroHandlerName
    bg.Parent = root
    bg.MaxTorque = v3inf
    bg.P = 1000
    bg.D = 50

    mfly1 = Players.LocalPlayer.CharacterAdded:Connect(function()
        local bv = Instance.new("BodyVelocity")
        bv.Name = velocityHandlerName
        bv.Parent = root
        bv.MaxForce = v3zero
        bv.Velocity = v3zero

        local bg = Instance.new("BodyGyro")
        bg.Name = gyroHandlerName
        bg.Parent = root
        bg.MaxTorque = v3inf
        bg.P = 1000
        bg.D = 50
    end)

    mfly2 = RunService.RenderStepped:Connect(function()
        root = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
        camera = workspace.CurrentCamera
        if Players.LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid") and root and root:FindFirstChild(velocityHandlerName) and root:FindFirstChild(gyroHandlerName) then
            local humanoid = Players.LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid")
            local VelocityHandler = root:FindFirstChild(velocityHandlerName)
            local GyroHandler = root:FindFirstChild(gyroHandlerName)

            VelocityHandler.MaxForce = v3inf
            GyroHandler.MaxTorque = v3inf
            humanoid.PlatformStand = true
            GyroHandler.CFrame = camera.CoordinateFrame
            VelocityHandler.Velocity = v3none

            local direction = controlModule:GetMoveVector()
            if direction.X > 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity + camera.CFrame.RightVector * (direction.X * ((iyflyspeed) * 50))
            end
            if direction.X < 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity + camera.CFrame.RightVector * (direction.X * ((iyflyspeed) * 50))
            end
            if direction.Z > 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity - camera.CFrame.LookVector * (direction.Z * ((iyflyspeed) * 50))
            end
            if direction.Z < 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity - camera.CFrame.LookVector * (direction.Z * ((iyflyspeed) * 50))
            end
        end
    end)
end


-- Key bindings for fly
UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.KeyCode == Enum.KeyCode.F then
        if not FLYING and ActivateFly then
            if UserInputService.TouchEnabled then
                MobileFly()
            else
                NOFLY()
                wait()
                sFLY()
            end
        elseif FLYING and ActivateFly then
            if UserInputService.TouchEnabled then
                UnMobileFly()
            else
                NOFLY()
            end
        end
    end
end)


-- ===================================================================
-- 💠 TELEPORTES (Rod, Item, Quest, NPC) — compatível com seu Fluent
-- Cole depois de criar:  local TeleportTab = Window:AddTab({ Title="Teleportes", Icon="navigation" })
-- ===================================================================

-- helper: pega chaves em lista (sem usar table.keys)
local function dictKeys(dict)
    local t = {}
    for k,_ in pairs(dict) do
        table.insert(t, k)
    end
    table.sort(t)
    return t
end

-- helper: teleporta com pequeno offset e guarda origem
local function doTeleport(targetCFrame, saveOriginVarName)
    local ok, err = pcall(function()
        local char = LocalPlayer.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            _G[saveOriginVarName] = char.HumanoidRootPart.CFrame
            char.HumanoidRootPart.CFrame = targetCFrame * CFrame.new(0, 5, 0)
        end
    end)
    if not ok then
        Fluent:Notify({ Title = "Teleporte", Content = "Erro: ".. tostring(err), Duration = 3 })
    end
end

-- =========================
-- 🔹 ROD TELEPORTS
-- =========================
local rodTeleportLocations = {
	["Training Rod"] = CFrame.new(457.693848, 148.357529, 230.414307),  
	["Plastic Rod"] = CFrame.new(454.425385, 148.169739, 229.172424), 
	["Carbon Rod"] = CFrame.new(454.083618, 150.590073, 225.328827), 
	["Long Rod"] = CFrame.new(485.695038, 171.656326, 145.746109), 
	["Fast Rod"] = CFrame.new(447.183563, 148.225739, 220.187454), 
	["Lucky Rod"] = CFrame.new(446.085999, 148.253006, 222.1600), 
	["Steady Rod"] = CFrame.new(-1511.23523, 139.679504, 759.417114), 
	["Fortune Rod"] = CFrame.new(-1520.87964, 141.283279, 771.946777), 
	["Rapid Rod"] = CFrame.new(-1509.24463, 139.725906, 759.628174), 
	["Nocturnal Rod"] = CFrame.new(-141.874237, -515.313538, 1139.04529), 
	["Aurora Rod"] = CFrame.new(-141.874237, -515.313538, 1139.04529), 
	["Rod Of The Depths"] = CFrame.new(1689.9, -902.4, 1437.7), 
	["Magnet Rod"] = CFrame.new(-194.998871, 130.148087, 1930.97107), 
	["King's Rod"] = CFrame.new(1375.57642, -810.201721, -303.509247), 
	["Reinforced Rod"] = CFrame.new(-986.474365, -245.473938, -2689.79248),
	["Trident Rod"] = CFrame.new(-1484.34192, -222.325562, -2194.77002),
	["Scurvy Rod"] = CFrame.new(-2828.21851, 213.457199, 1512.20959),
	["Phoenix Rod"] = CFrame.new(5971.03125, 270.377502, 852.372559),
	["Heaven's Rod"] = CFrame.new(19980, 916, 5384),
	["Summit Rod"] = CFrame.new(20207.7539, 736.058289, 5711.35156),
	["Avalanche Rod"] = CFrame.new(19770.1816, 415.680969, 5419.19678),
	["Ice Warper's Rod"] = CFrame.new(19965, 587, 5573),
	["Arctic Rod"] = CFrame.new(19578.2363, 132.338379, 5307.38281),
	["Abyssal Specter Rod"] = CFrame.new(-3804.09668, -566.402893, 1870.32849),
	["Kraken Rod"] = CFrame.new(-4415.41699, -995.66217, 2054.45312),
	["Depthseeker Rod"] = CFrame.new(-4466.24609, -596.11145, 1875.07166),
	["Champions Rod"] = CFrame.new(-4277.4541, -602.719604, 1839.05908),
	["Tempest Rod"] = CFrame.new(-4927.61865, -594.829651, 1856.89734),
	["Zeus Rod"] = CFrame.new(-4270.84521, -626.403259, 2664.3479),
	["Poseidon Rod"] = CFrame.new(-4086.14795, -557.409241, 895.166809),
	["Ethereal Prism Rod"] = CFrame.new(-4359.83936, -11172.4326, 3718.91968),
	["Leviathan's Fang Rod"] = CFrame.new(-2297.67651, -11185.3018, 7138.99023),
	["Rod Of The Zenith"] = CFrame.new(-13625.1162, -11034.4316, 357.60199),
	["Volcanic Rod"] = CFrame.new(-3178.24463, -2035.75085, 4021.57886),
	["Brick Rod"] = CFrame.new(1321, 140, 1540),
	["Crystalized Rod"] = CFrame.new(19240, 400, 6035),
}
TeleportTab:AddSection("Rod Teleports")
local _rodValues = dictKeys(rodTeleportLocations)
local _selectedRodName = _rodValues[1]
local RodDropdown = TeleportTab:AddDropdown("RodDropdown", {
    Title = "Escolha o Rod",
    Values = _rodValues,
    Multi = false,  -- Um único rod pode ser selecionado
    Default = 1,   -- O primeiro rod será selecionado por padrão
})
RodDropdown:OnChanged(function(v) _selectedRodName = v end)

TeleportTab:AddButton({
    Title = "Teleportar Rod",
    Description = "Vai para o Rod selecionado",
    Callback = function()
        local cf = rodTeleportLocations[_selectedRodName]
        if cf then doTeleport(cf, "__RodLastOrigin") end
    end
})
-- =========================
-- 🔹 ITEM TELEPORTS
-- =========================
local itemTeleportLocations = {
	["GPS"] = CFrame.new(517, 152, 284),  
	["Glider"] = CFrame.new(-1713, 149, 740),
	["Pickaxe"] = CFrame.new(19783.1914, 415.743622, 5391.92041),
	["Advanced Glider"] = CFrame.new(19939, 1142, 5544),
	["Heart Of Zeus"] = CFrame.new(-2522, 138, 1593),
	["Drill"] = CFrame.new(0, -85.39099884033203, 0),
	["Crab Cage"] = CFrame.new(465, 150, 235),
	["Conception Conch"] = CFrame.new(-145, -515, 1140),
	["Common Crate"] = CFrame.new(-1140, 125, -1076),
	["Sundial Totem"] = CFrame.new(-1215, 195, -1040),
	["Tempest Totem"] = CFrame.new(20, 140, 1860),
	["Windset Totem"] = CFrame.new(2845, 180, 2700),
	["Smokescreen Totem"] = CFrame.new(2790, 140, -625),
	["Meteor Totem"] = CFrame.new(-1945, 275, 230),
	["Avalanche Totem"] = CFrame.new(19711, 468, 6059),
	["Eclipse Totem"] = CFrame.new(5940, 265, 900),
	["Blizzard Totem"] = CFrame.new(20148, 743, 5804),
	["Aurora Totem"] = CFrame.new(-1810, -135, -3280),
	["Cursed Storm Totem"] = CFrame.new(760, 2130, 16965),
	["Zeus Storm Totem"] = CFrame.new(-4325, -625, 2685),
	["Poseidon Wrath Totem"] = CFrame.new(-3955, -555, 855),
}
TeleportTab:AddSection("Item Teleports")
local _itemValues = dictKeys(itemTeleportLocations)
local _selectedItemName = _itemValues[1]
local ItemDropdown = TeleportTab:AddDropdown("ItemDropdown", {
    Title = "Escolha o Item",
    Values = _itemValues,
    Multi = false,  -- Um único item pode ser selecionado
    Default = 1,   -- O primeiro item será selecionado por padrão
})
ItemDropdown:OnChanged(function(v) _selectedItemName = v end)

TeleportTab:AddButton({
    Title = "Teleportar Item",
    Description = "Vai para o Item selecionado",
    Callback = function()
        local cf = itemTeleportLocations[_selectedItemName]
        if cf then doTeleport(cf, "__ItemLastOrigin") end
    end
})

-- =========================
-- 🔹 QUEST TELEPORTS
-- =========================
local questTeleportLocations = {
	["Lost Rod"] = CFrame.new(2930, 130, 2620),
	["Roslit Brick"] = CFrame.new(-1844, 194.5, 196.1),
	["Ancient Isles Brick"] = CFrame.new(5959, 269, 850),
	["The Depths Brick"] = CFrame.new(989, -734, 1136),
	["Blue Energy Crystal"] = CFrame.new(20125, 211, 5450),
	["Green Energy Crystal"] = CFrame.new(19870, 448, 5555),
	["Yellow Energy Crystal"] = CFrame.new(19500, 335, 5550),
	["Red Energy Crystal"] = CFrame.new(19920, 1140, 5350),
	["Button 1"] = CFrame.new(400, 136, 265),
	["Button 2"] = CFrame.new(-1716, 149, 732),
	["Button 3"] = CFrame.new(-2566, 181, 1353),
	["Button 4"] = CFrame.new(2930, 281, 2594),
	["Button 5"] = CFrame.new(5506, 147, -315),
	["TNT Lever 1"] = CFrame.new(-2522, 138, 1593),
	["TNT Lever 2"] = CFrame.new(-2551, 150, 1667),
	["TNT Lever 3"] = CFrame.new(-2729, 168, 1730),
	["TNT Lever 4"] = CFrame.new(-2881, 314, 1605),
	["TNT Lever 5"] = CFrame.new(-2835, 131, 1510),
}
TeleportTab:AddSection("Quest Teleports")
local _questValues = dictKeys(questTeleportLocations)
local _selectedQuestName = _questValues[1]
local QuestDropdown = TeleportTab:AddDropdown("QuestDropdown", {
    Title = "Escolha a Quest",
    Values = _questValues,
    Multi = false,  -- Um único quest pode ser selecionado
    Default = 1,   -- O primeiro quest será selecionado por padrão
})
QuestDropdown:OnChanged(function(v) _selectedQuestName = v end)

TeleportTab:AddButton({
    Title = "Teleportar Quest",
    Description = "Vai para a Quest selecionada",
    Callback = function()
        local cf = questTeleportLocations[_selectedQuestName]
        if cf then doTeleport(cf, "__QuestLastOrigin") end
    end
})

-- =========================
-- 🔹 NPC TELEPORTS
-- =========================
local npcTeleportLocations = {
	["Jack Marrow"] = CFrame.new(-2830, 215, 1518),
	["Merchant"] = CFrame.new(466, 151, 225),
	["Skin Merchant"] = CFrame.new(415, 135, 190),
	["Angler"] = CFrame.new(480, 150, 295),
	["Shipwright"] = CFrame.new(360, 135, 260),
	["Inn Keeper"] = CFrame.new(490, 150, 245),
	["Submariner"] = CFrame.new(-3355, -2270, 3800),
	["Egg Salesman"] = CFrame.new(375, 135, 320),
	["Sea Traveler"] = CFrame.new(140, 150, 2030),
	["Lantern Keeper"] = CFrame.new(710, 165, 335),
	["Phineas"] = CFrame.new(470, 150, 275),
	["Captain Ahab"] = CFrame.new(362, 133, 294),
	["Alfie"] = CFrame.new(-1515, 141, 765),
	["Ashe"] = CFrame.new(-1705, 150, 735),
	["Dr Glimmerfin"] = CFrame.new(-1320, 130, 300),
	["Orc"] = CFrame.new(-1850, 165, 160),
	["Wilson"] = CFrame.new(2935, 280, 2565),
	["Merlin"] = CFrame.new(-928, 224, -998),
	["Silas"] = CFrame.new(1545, 1690, 6310),
	["Agaric"] = CFrame.new(2595, 130, -725),
	["Synth"] = CFrame.new(-145, -515, 1140),
	["The Keeper"] = CFrame.new(20, -705, 1255),
	["Caleia"] = CFrame.new(980, 130, -1235),
	["Minish"] = CFrame.new(-1322, 140, 1543),
	["Chiseler"] = CFrame.new(6087, 195, 294),
	["Meteoriticist"] = CFrame.new(5922, 262, 596),
	["Hiker"] = CFrame.new(19526, 132, 5236),
	["Bubble Mermaid"] = CFrame.new(-3550, 130, 568),
	["Captain Neptune"] = CFrame.new(-3820, 135, 575),
	["Dr. Crookspine"] = CFrame.new(-1915, 225, -530),
}
TeleportTab:AddSection("NPC Teleports")
local _npcValues = dictKeys(npcTeleportLocations)
local _selectedNpcName = _npcValues[1]
local NpcDropdown = TeleportTab:AddDropdown("NpcDropdown", {
    Title = "Escolha o NPC",
    Values = _npcValues,
    Multi = false,  -- Um único NPC pode ser selecionado
    Default = 1,   -- O primeiro NPC será selecionado por padrão
})
NpcDropdown:OnChanged(function(v) _selectedNpcName = v end)

TeleportTab:AddButton({
    Title = "Teleportar NPC",
    Description = "Vai para o NPC selecionado",
    Callback = function()
        local cf = npcTeleportLocations[_selectedNpcName]
        if cf then doTeleport(cf, "__NpcLastOrigin") end
    end
})


HideUIToggle:OnChanged(function(value)
    Settings.HideUI = value
    if LocalPlayer.PlayerGui:FindFirstChild("hud") then
        LocalPlayer.PlayerGui.hud.safezone.Visible = not value
    end
end)


-- =========================
-- 🔹 ANTI AFK
-- =========================
MainTab:AddSection("Anti AFK")

local AntiAFKToggle = MainTab:AddToggle("AntiAFK", {
    Title = "ANTI AFK",
    Default = false
})

AntiAFKToggle:OnChanged(function(value)
    Settings.AntiAFK = value
    if value then
        AntiAFKConnection = game:GetService("Players").LocalPlayer.Idled:Connect(function()
            if Settings.AntiAFK then
                game:GetService("VirtualUser"):CaptureController()
                game:GetService("VirtualUser"):ClickButton2(Vector2.new())
            end
        end)
    else
        if AntiAFKConnection then
            AntiAFKConnection:Disconnect()
            AntiAFKConnection = nil
        end
    end
end)


-- COPIAR POSIÇÃO
local CopyPosToggle = PlayerTab:AddButton("CopyPos", {
    Title = "📍 COPIAR POSIÇÃO",
    Default = false
})

CopyPosToggle:OnChanged(function(Value)
    if Value then
        local pos = LocalPlayer.Character.HumanoidRootPart.Position
        setclipboard(string.format("CFrame.new(%.1f, %.1f, %.1f)", pos.X, pos.Y, pos.Z))
        Fluent:Notify({
            Title = "Posição",
            Content = "Posição copiada para clipboard!",
            Duration = 3
        })
        CopyPosToggle:SetValue(false)
    end
end)



-- Anti Kick / Anti Disconnect
local ThirdPartyUserService = game:GetService("ThirdPartyUserService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Override de Kick
if LocalPlayer then
    -- Substitui a função Kick do jogador
    local mt = getrawmetatable(game)
    setreadonly(mt, false)
    
    local oldIndex = mt.__namecall
    mt.__namecall = newcclosure(function(self, ...)
        local args = {...}
        local method = getnamecallmethod()
        
        if method == "Kick" then
            warn("Tentativa de Kick bloqueada!")
            return
        end
        
        return oldIndex(self, ...)
    end)
    
    setreadonly(mt, true)
end

-- Também previne kicks via ThirdPartyUserService
if ThirdPartyUserService then
    ThirdPartyUserService.Kick:Connect(function(reason)
        warn("ThirdPartyUserService tentou kicker você, mas foi bloqueado! Razão: "..tostring(reason))
        -- Você pode até exibir uma notificação na tela se quiser
        if game:GetService("Players").LocalPlayer then
            game:GetService("Players").LocalPlayer:Kick("Bloqueado temporariamente pelo Anti-Kick")
        end
    end)
end

print("Anti-Kick ativo!")


-- Configurar SaveManager e InterfaceManager
SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)

-- Configurar pasta de save
SaveManager:SetFolder("SOWxTEAM")

-- Configurar configurações que serão salvas
SaveManager:BuildConfigSection(MiscTab)
InterfaceManager:BuildInterfaceSection(MiscTab)

-- Carregar configurações
SaveManager:LoadAutoloadConfig()

-- Atualizar automaticamente quando um jogador entra/sai
Players.PlayerAdded:Connect(function()
    PlayerDropdown:SetValues(UpdatePlayerList())
end)

Players.PlayerRemoving:Connect(function()
    PlayerDropdown:SetValues(UpdatePlayerList())
end)

-- Notificação inicial
Fluent:Notify({
    Title = "SOWxTEAM",
    Content = "Script carregado com sucesso!",
    Duration = 5
})
