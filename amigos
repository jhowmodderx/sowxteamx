local _ENV = (getgenv or getrenv or getfenv)()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local DialogueEvent = ReplicatedStorage.BetweenSides.Remotes.Events.DialogueEvent
local CombatEvent = ReplicatedStorage.BetweenSides.Remotes.Events.CombatEvent
local ToolEvent = ReplicatedStorage.BetweenSides.Remotes.Events.ToolsEvent
local QuestsNpcs = workspace.IgnoreList.Int.NPCs.Quests
local Enemys = workspace.Playability.Enemys
local QuestsDecriptions = require(ReplicatedStorage.MainModules.Essentials.QuestDescriptions)
local EnemiesFolders = {}
local CFrameAngle = CFrame.Angles(math.rad(- 90), 0, 0)

local function a()
    local QuestsList = {}
    local CurrentQuest = nil
    local CurrentLevel = - 1
    for _, QuestData in QuestsDecriptions do
        if QuestData.Goal <= 1 then
            continue
        end
        table.insert(QuestsList, {
            Level = QuestData.MinLevel,
            Target = QuestData.Target,
            NpcName = QuestData.Npc,
            Id = QuestData.Id
        })
    end
    table.sort(QuestsList, function(a, b)
        return a.Level > b.Level
    end)
    local function b()
        local Level = nil
        local success, result = pcall(function()
            local mainUI = Player.PlayerGui:FindFirstChild("MainUI")
            if mainUI then
                local mainFrame = mainUI:FindFirstChild("MainFrame")
                if mainFrame then
                    local statsFrame = mainFrame:FindFirstChild("StastisticsFrame") or mainFrame:FindFirstChild("StatisticsFrame")
                    if statsFrame then
                        local levelBG = statsFrame:FindFirstChild("LevelBackground")
                        if levelBG then
                            local levelText = levelBG:FindFirstChild("Level")
                            if levelText and levelText.Text then
                                return tonumber(levelText.Text)
                            end
                        end
                        for _, child in pairs(statsFrame:GetDescendants()) do
                            if child:IsA("TextLabel") and child.Text:match("^%d+$") then
                                local num = tonumber(child.Text)
                                if num and num >= 1 and num <= 2000 then
                                    return num
                                end
                            end
                        end
                    end
                end
            end
            return 1
        end)
        if success and result then
            Level = result
        else
            Level = 1
        end
        if Level == CurrentLevel then
            return CurrentQuest
        end
        for _, QuestData in QuestsList do
            if QuestData.Level <= Level then
                CurrentLevel, CurrentQuest = Level, QuestData
                return QuestData
            end
        end
        return nil
    end
    return b()
end

local Settings = {
    ClickV2 = false,
    TweenSpeed = 270,
    SelectedTool = "CombatType",
    BringMobDistance = 35,
    dSpeed = 0.05,
    NoClip = false,
    AutoStats = false,
    SelectedStat = "Strength"
}

local EquippedTool = nil
local CurrentTarget = nil

local conepc = _ENV.cnn or {}
_ENV.cnn = conepc

for i = 1, # conepc do
    conepc[i]:Disconnect()
end

table.clear(conepc)

local function c(Character)
    if Character then
        local Humanoid = Character:FindFirstChildOfClass("Humanoid")
        return Humanoid and Humanoid.Health > 0
    end
end

local BodyVelocity = Instance.new("BodyVelocity")
BodyVelocity.Velocity = Vector3.zero
BodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
BodyVelocity.P = 1000

if _ENV.tween_bodyvelocity then
    _ENV.tween_bodyvelocity:Destroy()
end

_ENV.tween_bodyvelocity = BodyVelocity

local CanCollideObjects = {}

local function ss(Object)
    if Object:IsA("BasePart") and Object.CanCollide then
        table.insert(CanCollideObjects, Object)
    end
end

local function rrr(BasePart)
    local index = table.find(CanCollideObjects, BasePart)
    if index then
        table.remove(CanCollideObjects, index)
    end
end

local function ne(Character)
    table.clear(CanCollideObjects)
    for _, Object in Character:GetDescendants() do
        ss(Object)
    end
    Character.DescendantAdded:Connect(ss)
    Character.DescendantRemoving:Connect(rrr)
end

table.insert(conepc, Player.CharacterAdded:Connect(ne))
task.spawn(ne, Player.Character)

local function np(Character)
    if _ENV.OnFarm then
        for i = 1, # CanCollideObjects do
            CanCollideObjects[i].CanCollide = false
        end
    elseif Character.PrimaryPart and not Character.PrimaryPart.CanCollide then
        for i = 1, # CanCollideObjects do
            CanCollideObjects[i].CanCollide = true
        end
    end
end

local function upe(Character)
    local BasePart = Character:FindFirstChild("UpperTorso")
    local Humanoid = Character:FindFirstChild("Humanoid")
    local BodyVelocity = _ENV.tween_bodyvelocity
    if _ENV.OnFarm and BasePart and Humanoid and Humanoid.Health > 0 then
        if BodyVelocity.Parent ~= BasePart then
            BodyVelocity.Parent = BasePart
        end
    elseif BodyVelocity.Parent then
        BodyVelocity.Parent = nil
    end
    if BodyVelocity.Velocity ~= Vector3.zero and (not Humanoid or not Humanoid.SeatPart or not _ENV.OnFarm) then
        BodyVelocity.Velocity = Vector3.zero
    end
end

table.insert(conepc, RunService.Stepped:Connect(function()
    local Character = Player.Character
    if c(Character) then
        upe(Character)
        np(Character)
    end
end))

local TweenCreator = {}
TweenCreator.__index = TweenCreator

local tweens = {}
local EasingStyle = Enum.EasingStyle.Linear

function TweenCreator.new(obj, time, prop, value)
    local self = setmetatable({}, TweenCreator)
    self.tween = TweenService:Create(obj, TweenInfo.new(time, EasingStyle), {
        [prop] = value
    })
    self.tween:Play()
    self.value = value
    self.object = obj
    if tweens[obj] then
        tweens[obj]:destroy()
    end
    tweens[obj] = self
    return self
end

function TweenCreator:destroy()
    self.tween:Pause()
    self.tween:Destroy()
    tweens[self.object] = nil
    setmetatable(self, nil)
end

function TweenCreator:stopTween(obj)
    if obj and tweens[obj] then
        tweens[obj]:destroy()
    end
end

local function TweenStopped()
    if not BodyVelocity.Parent and c(Player.Character) then
        TweenCreator:stopTween(Player.Character:FindFirstChild("HumanoidRootPart"))
    end
end

local lastCFrame = nil
local lastTeleport = 0

-- Função de Teleporte com correção para movimentação após o teleporte
local function tepe(TargetCFrame)
    -- Verifica se o jogador e a parte principal estão disponíveis
    local Player = game.Players.LocalPlayer
    local Character = Player.Character
    if not Character or not Character.PrimaryPart then
        return false
    end

    -- Evita teletransportes repetidos de forma rápida
    if (tick() - lastTeleport) <= 0.3 and lastCFrame == TargetCFrame then
        return false
    end

    -- Atualiza os valores de teleporte
    lastTeleport = tick()
    lastCFrame = TargetCFrame

    -- Teleportando o personagem para o destino
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    if HumanoidRootPart then
        -- Desativando colisão temporária para evitar problemas após o teleporte
        HumanoidRootPart.CanCollide = false

        -- Teleportando o personagem
        HumanoidRootPart.CFrame = TargetCFrame

        -- Espera um pouco para garantir que o teleporte foi realizado
        task.wait(0.1)

        -- Reativando colisão após o teleporte
        HumanoidRootPart.CanCollide = true
        return true
    end

    return false
end

table.insert(conepc, BodyVelocity:GetPropertyChangedSignal("Parent"):Connect(TweenStopped))

local CurrentTime = workspace:GetServerTimeNow()

local function d()
    if not c(Player.Character) then
        return
    end
    local Tool = Player.Character:FindFirstChildOfClass("Tool")
    if not Tool then
        return
    end
    CurrentTime = workspace:GetServerTimeNow()
    pcall(function()
        Tool:Activate()
        local Handle = Tool:FindFirstChild("Handle")
        if Handle then
            if Handle:FindFirstChild("Cooldown") then
                Handle.Cooldown.Value = 0
            end
            if Handle:FindFirstChild("AttackCooldown") then
                Handle.AttackCooldown.Value = 0
            end
            if Handle:FindFirstChild("Debounce") then
                Handle.Debounce.Value = false
            end
            local Sound = Handle:FindFirstChildOfClass("Sound")
            if Sound then
                Sound:Play()
            end
        end
        ToolEvent:FireServer("Effects", 1)
        ToolEvent:FireServer("Activate", 1)
        if Settings.ClickV2 then
            for i = 1, 3 do
                Tool:Activate()
                task.wait(0.01)
            end
        end
    end)
end

local function faz(Enemies)
    CurrentTime = workspace:GetServerTimeNow()
    CombatEvent:FireServer("DealDamage", {
        CallTime = CurrentTime,
        DelayTime = 0,
        Combo = 1,
        Results = Enemies,
        Damage = math.random(50, 150),
        CriticalHit = math.random(1, 10) <= 3
    })
end

local function irl(Folder, EnemyName)
    local foundEnemies = {}
    for _, Enemy in pairs(Folder:GetChildren()) do
        if Enemy and Enemy.Parent then
            local enemyName = Enemy:GetAttribute("OriginalName") or Enemy:GetAttribute("EnemyName") or Enemy.Name
            if enemyName == EnemyName or string.find(enemyName, EnemyName) then
                local Humanoid = Enemy:FindFirstChild("Humanoid")
                local HumanoidRootPart = Enemy:FindFirstChild("HumanoidRootPart")
                if Humanoid and HumanoidRootPart and Humanoid.Health > 0 then
                    local isReady = true
                    if Enemy:GetAttribute("Respawned") ~= nil then
                        isReady = Enemy:GetAttribute("Respawned")
                    end
                    if Enemy:GetAttribute("Ready") ~= nil then
                        isReady = isReady and Enemy:GetAttribute("Ready")
                    end
                    if isReady then
                        table.insert(foundEnemies, Enemy)
                    end
                end
            end
        end
    end
    return foundEnemies
end

local function pgaall(EnemyName)
    local AllEnemies = {}
    local EnemyFolder = EnemiesFolders[EnemyName]
    if EnemyFolder and EnemyFolder.Parent then
        local enemies = irl(EnemyFolder, EnemyName)
        for _, enemy in ipairs(enemies) do
            table.insert(AllEnemies, enemy)
        end
    else
        if Enemys and Enemys.Parent then
            local Islands = Enemys:GetChildren()
            for i = 1, # Islands do
                local Island = Islands[i]
                if Island and Island.Parent then
                    local enemies = irl(Island, EnemyName)
                    if # enemies > 0 then
                        EnemiesFolders[EnemyName] = Island
                        for _, enemy in ipairs(enemies) do
                            table.insert(AllEnemies, enemy)
                        end
                    end
                end
            end
        end
    end
    return AllEnemies
end

local function clst(EnemyName)
    local AllEnemies = pgaall(EnemyName)
    if # AllEnemies == 0 then
        return nil
    end
    local ClosestEnemy = nil
    local ShortestDistance = math.huge
    for i, Enemy in ipairs(AllEnemies) do
        if Enemy and Enemy.Parent then
            local RootPart = Enemy:FindFirstChild("HumanoidRootPart")
            local Humanoid = Enemy:FindFirstChild("Humanoid")
            if RootPart and Humanoid and Humanoid.Health > 0 then
                local Distance = Player:DistanceFromCharacter(RootPart.Position)
                if Distance < ShortestDistance then
                    ShortestDistance = Distance
                    ClosestEnemy = Enemy
                end
            end
        end
    end
    return ClosestEnemy
end

local function brnge(EnemyName, TargetPosition)
    if not _ENV.BringMob then
        return 0
    end
    local AllEnemies = pgaall(EnemyName)
    local BroughtCount = 0
    if # AllEnemies == 0 then
        return 0
    end
    for i, Enemy in ipairs(AllEnemies) do
        if Enemy and Enemy.Parent then
            local RootPart = Enemy:FindFirstChild("HumanoidRootPart")
            local Humanoid = Enemy:FindFirstChild("Humanoid")
            if RootPart and Humanoid and Humanoid.Health > 0 then
                if not RootPart:FindFirstChild("BodyVelocity") then
                    local BV = Instance.new("BodyVelocity", RootPart)
                    BV.Velocity = Vector3.zero
                    BV.MaxForce = Vector3.one * math.huge
                end
                RootPart.CanCollide = false
                RootPart.Size = Vector3.one * Settings.BringMobDistance
                RootPart.CFrame = TargetPosition
                BroughtCount = BroughtCount + 1
            end
        end
    end
    if BroughtCount > 0 then
        pcall(sethiddenproperty, Player, "SimulationRadius", math.huge)
    end
    return BroughtCount
end

local function IsSelectedTool(Tool)
    return Tool:GetAttribute(Settings.SelectedTool)
end

local function EquipCombat(Activate)
    if not c(Player.Character) then
        return
    end
    if EquippedTool and IsSelectedTool(EquippedTool) then
        if Activate then
            if Settings.ClickV2 then
                d()
            else
                EquippedTool:Activate()
            end
        end
        if EquippedTool.Parent == Player.Backpack then
            Player.Character.Humanoid:EquipTool(EquippedTool)
        elseif EquippedTool.Parent ~= Player.Character then
            EquippedTool = nil
        end
        return
    end
    local Equipped = Player.Character:FindFirstChildOfClass("Tool")
    if Equipped and IsSelectedTool(Equipped) then
        EquippedTool = Equipped
        return
    end
    for _, Tool in Player.Backpack:GetChildren() do
        if Tool:IsA("Tool") and IsSelectedTool(Tool) then
            EquippedTool = Tool
            Player.Character.Humanoid:EquipTool(Tool)
            return
        end
    end
end

local function ten(EnemyName)
    local success, result = pcall(function()
        local QuestFrame = Player.PlayerGui.MainUI.MainFrame.CurrentQuest
        if not QuestFrame.Visible then
            return false
        end
        local questText = nil
        local goalElement = QuestFrame:FindFirstChild("Goal")
        if goalElement and goalElement.Text then
            questText = goalElement.Text
        end
        if not questText then
            for _, child in pairs(QuestFrame:GetDescendants()) do
                if child:IsA("TextLabel") and child.Text and child.Text ~= "" then
                    if string.find(child.Text, "Defeat") or string.find(child.Text, "/") then
                        questText = child.Text
                        break
                    end
                end
            end
        end
        if questText then
            local hasTargetQuest = string.find(questText, EnemyName)
            return hasTargetQuest ~= nil
        else
            return false
        end
    end)
    if success then
        return result
    else
        return false
    end
end

local function ete(QuestName, QuestId)
    local Npc = QuestsNpcs:FindFirstChild(QuestName, true)
    local RootPart = Npc and Npc.PrimaryPart
    if RootPart then
        DialogueEvent:FireServer("Quests", {
            ["NpcName"] = QuestName,
            ["QuestName"] = QuestId
        })
        tepe(RootPart.CFrame * CFrame.new(0, 0, 15))
        task.wait(2)
    end
end




local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/jhowmodderxxxx/haxstore/refs/heads/main/savemanagerhax"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/jhowmodderxxxx/haxstore/refs/heads/main/interface"))()

local DeviceType = game:GetService("UserInputService").TouchEnabled and "Mobile" or "PC"


--<>----<>----<>----< Anti Afk >----<>----<>----<>--
game.Players.LocalPlayer.Idled:Connect(function()
    VirtualUser:CaptureController()
    VirtualUser:ClickButton2(Vector2.new())
    print("Roblox Tried to kick you but we didn't let them kick you :D")
end)
warn("[Anti Afk] - loaded successfully") 


local UserInputService = game:GetService("UserInputService")
local Player = game.Players.LocalPlayer
local PlayerGui = Player:WaitForChild("PlayerGui")

local ClickButton = Instance.new("ScreenGui")
ClickButton.Parent = PlayerGui

local MainFrame = Instance.new("Frame")
MainFrame.Name = "LogoButton"
MainFrame.Parent = ClickButton
MainFrame.AnchorPoint = Vector2.new(1, 0)
MainFrame.BackgroundTransparency = 0.8
MainFrame.BackgroundColor3 = Color3.fromRGB(38, 38, 38)
MainFrame.BorderSizePixel = 0
MainFrame.Position = UDim2.new(1, -60, 0, 10)
MainFrame.Size = UDim2.new(0, 45, 0, 45)

local UICorner = Instance.new("UICorner")
UICorner.Parent = MainFrame

local TextButton = Instance.new("TextButton")
TextButton.Parent = MainFrame
TextButton.BackgroundColor3 = Color3.fromRGB(0, 255, 255)
TextButton.BackgroundTransparency = 1
TextButton.BorderSizePixel = 0
TextButton.Size = UDim2.new(1, 0, 1, 0)
TextButton.Text = "SOWxTEAM"
TextButton.TextColor3 = Color3.fromRGB(170, 0, 255)
TextButton.TextSize = 14
TextButton.AutoButtonColor = false


local ImageLabel = Instance.new("ImageLabel")
ImageLabel.Parent = TextButton
ImageLabel.AnchorPoint = Vector2.new(0.5, 0.5)
ImageLabel.BackgroundTransparency = 1
ImageLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
ImageLabel.Size = UDim2.new(1, 0, 1, 0)
ImageLabel.Image = "rbxassetid://78127779035849"
ImageLabel.ZIndex = 1

TextButton.ZIndex = 2



local ModMenu = Instance.new("Frame")
ModMenu.Name = "ModMenu"
ModMenu.Parent = PlayerGui
ModMenu.AnchorPoint = Vector2.new(0.5, 0.5)
ModMenu.BackgroundTransparency = 0.8
ModMenu.BackgroundColor3 = Color3.fromRGB(38, 38, 38)
ModMenu.BorderSizePixel = 0
ModMenu.Position = UDim2.new(0.5, 0, 0.5, 0)
ModMenu.Size = UDim2.new(0, 200, 0, 300)
ModMenu.Visible = false

local UICorner_2 = Instance.new("UICorner")
UICorner_2.Parent = ModMenu

TextButton.MouseButton1Click:Connect(function()
    ModMenu.Visible = not ModMenu.Visible
end)


if DeviceType == "Mobile" then
    MainFrame.Position = UDim2.new(1, -60, 0, 10)
else
    MainFrame.Position = UDim2.new(1, -120, 0, 10)

end



local UserInputService = game:GetService("UserInputService") 
local dragging, dragInput, dragStart, startPos

local function update(input)
    local delta = input.Position - dragStart
    MainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end


--mexer o flutuante com nome hax store no pc--
MainFrame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = MainFrame.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then dragging = false
                dragging = false

                 end 
  
            end) 

       end 

  end)








--mexer o flutuante com nome hax store no mobile--
  MainFrame.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input

    end 

end)

UserInputService.InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        update(input)

    end 
end)


TextButton.MouseButton1Click:Connect(function()
    game:GetService("VirtualInputManager"):SendKeyEvent(true, "LeftAlt", false, game)
    game:GetService("VirtualInputManager"):SendKeyEvent(false, "LeftAlt", false, game)
end)

local Window = Fluent:CreateWindow({
    Title = "SOWxTEAM",
    SubTitle = "By RodrigoGTyx",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = false,
    Theme = "Amethyst",
    MinimizeKey = Enum.KeyCode.LeftAlt
})

local Tabs = {
    Main = Window:AddTab({
        Title = "Farm",
    }),
    Misc = Window:AddTab({
        Title = "Outros",
    }),
    Server = Window:AddTab({
        Title = "Server",
        }),
}

Tabs.Main:AddSection("Auto Farm")
Tabs.Main:AddToggle("AutoFarm", {
    Title = "Auto Farm",
    Default = false,
    Callback = function(Value)
        _ENV.OnFarm = Value
        if Value then
            task.spawn(function()
                while task.wait(Settings.dSpeed) and _ENV.OnFarm do
                    if not c(Player.Character) then
                        repeat
                            task.wait(0.5)
                        until c(Player.Character)
                        task.wait(0.2)
                        continue
                    end
                    local CurrentQuest = a()
                    if not CurrentQuest then
                        continue
                    end
                    if not ten(CurrentQuest.Target) then
                        ete(CurrentQuest.NpcName, CurrentQuest.Id)
                        continue
                    end
                    local Enemy = clst(CurrentQuest.Target)
                    if not Enemy then
                        continue
                    end
                    CurrentTarget = Enemy
                    local HumanoidRootPart = Enemy:FindFirstChild("HumanoidRootPart")
                    local Humanoid = Enemy:FindFirstChild("Humanoid")
                    if HumanoidRootPart and Humanoid and Humanoid.Health > 0 then
                        if _ENV.BringMob then
                            brnge(CurrentQuest.Target, HumanoidRootPart.CFrame)
                        end
                        local targetCFrame = HumanoidRootPart.CFrame * CFrame.new(0, 7.5, 0) * CFrameAngle
                        if not tepe(targetCFrame) then
                            if Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") then
                                Player.Character.HumanoidRootPart.CFrame = targetCFrame
                            end
                        end
                        task.wait(0)
                        local AllQuestEnemies = pgaall(CurrentQuest.Target)
                        if # AllQuestEnemies > 0 then
                            faz(AllQuestEnemies)
                        end
                        d()
                    end
                end
            end)
        end
    end
})

Tabs.Main:AddToggle("BringMob", {
    Title = "Bring Mob",
    Default = false,
    Callback = function(Value)
        _ENV.BringMob = Value
    end
})

Tabs.Main:AddSection("Config")
local ToolDropdown = Tabs.Main:AddDropdown("ToolDropdown", {
    Title = "Selecione Melee e etc",
    Values = {},
    Multi = false,
    Default = nil
})
local ToolToggle = Tabs.Main:AddToggle("ToolToggle", {
    Title = "Equipar item de farm automaticamente",
    Default = false
})
local equipping = false
local function EquipSelectedTool()
    if not ToolToggle.Value then
        return
    end
    if equipping then
        return
    end
    equipping = true
    local selectedTool = ToolDropdown.Value
    if selectedTool then
        local tool = Player.Backpack:FindFirstChild(selectedTool)
        if tool and Player.Character and Player.Character:FindFirstChild("Humanoid") then
            pcall(function()
                Player.Character.Humanoid:EquipTool(tool)
            end)
        end
    end
    equipping = false
end
Player.CharacterAdded:Connect(function(character)
    character:WaitForChild("Humanoid")
    if ToolToggle.Value then
        task.wait(1)
        EquipSelectedTool()
    end
end)
ToolToggle:OnChanged(function(Value)
    if Value then
        coroutine.wrap(function()
            while ToolToggle.Value do
                EquipSelectedTool()
                task.wait(0.1)
            end
        end)()
    else
        if Player.Character then
            local currentTool = Player.Character:FindFirstChildOfClass("Tool")
            if currentTool then
                currentTool.Parent = Player.Backpack
            end
        end
    end
end)
local function RefreshTools()
    local tools = {}
    if Player and Player:FindFirstChild("Backpack") then
        for _, tool in ipairs(Player.Backpack:GetChildren()) do
            if tool:IsA("Tool") then
                table.insert(tools, tool.Name)
            end
        end
    end
    ToolDropdown:SetValues(tools)
end
local RefreshButton = Tabs.Main:AddButton({
    Title = "Recarregar",
    Callback = RefreshTools
})
task.spawn(function()
    task.wait(2)
    RefreshTools()
end)
Tabs.Main:AddSection("Auto Stats")
local StatDropdown = Tabs.Main:AddDropdown("StatDropdown", {
    Title = "Selecione onde colocar pontos",
    Values = {
        "Soco",
        "Vida",
        "Espada",
        "Arma",
        "Fruta"
    },
    Multi = false,
    Default = "Soco",
    Callback = function(Value)
        Settings.SelectedStat = Value
    end
})
local AutoStatsToggle = Tabs.Main:AddToggle("AutoStatsToggle", {
    Title = "Auto Stats Selecionado",
    Default = false,
    Callback = function(Value)
        Settings.AutoStats = Value
        if Value then
            coroutine.wrap(function()
                while Settings.AutoStats do
                    local remote = ReplicatedStorage.BetweenSides.Remotes.Events.StatsEvent
                    if remote then
                        local args = {
                            "UpgradeStat",
                            {
                                Defense = Settings.SelectedStat == "Vida" and 1 or 0,
                                Sword = Settings.SelectedStat == "Espada" and 1 or 0,
                                Gun = Settings.SelectedStat == "Arma" and 1 or 0,
                                Strength = Settings.SelectedStat == "Soco" and 1 or 0,
                                DevilFruit = Settings.SelectedStat == "Fruta" and 1 or 0
                            }
                        }
                        pcall(function()
                            remote:FireServer(unpack(args))
                        end)
                    end
                    task.wait(0.1)
                end
            end)()
        end
    end
})

local char = game:GetService("Players").LocalPlayer.Character or game:GetService("Players").LocalPlayer.CharacterAdded:Wait()
local fireTouchEnabled = false
local function fireTouch(part)
    if not fireTouchEnabled or not part:IsA("BasePart") then
        return
    end
    for _, ti in ipairs(part:GetChildren()) do
        if ti:IsA("TouchTransmitter") then
            for _, myPart in ipairs(char:GetDescendants()) do
                if myPart:IsA("BasePart") then
                    firetouchinterest(myPart, part, 0)
                    task.wait()
                    firetouchinterest(myPart, part, 1)
                end
            end
        end
    end
end
Tabs.Misc:AddSection("Teleportes")
local islands = {}
local map = workspace:FindFirstChild("Map")
if map then
    for _, island in ipairs(map:GetChildren()) do
        if island:FindFirstChild("Base") then
            table.insert(islands, island.Name)
        end
    end
end
local IslandDropdown = Tabs.Misc:AddDropdown("IslandDropdown", {
    Title = "Selecione a Ilha",
    Values = islands,
    Multi = false,
    Default = islands[1] or nil
})
Tabs.Misc:AddButton({
    Title = "Ir Para Ilha",
    Callback = function()
        local selectedIsland = IslandDropdown.Value
        if selectedIsland and map then
            local island = map:FindFirstChild(selectedIsland)
            if island and island:FindFirstChild("Base") then
                local base = island.Base
                if base:FindFirstChild("HumanoidRootPart") then
                    game.Players.LocalPlayer.Character:MoveTo(base.HumanoidRootPart.Position)
                else
                    game.Players.LocalPlayer.Character:MoveTo(base.WorldPivot.Position + Vector3.new(0, 5, 0))
                end
            end
        end
    end
})

Tabs.Misc:AddSection("Farm Baú")
Tabs.Misc:AddToggle("FireTouchToggle", {
    Title = "Auto baú e fruta Spawnadas",
    Default = false,
    Callback = function(value)
        fireTouchEnabled = value
        if value then
            for _, v in ipairs(workspace:GetDescendants()) do
                fireTouch(v)
            end
        end
    end
})

local function clicarParaFalarComNPC()
    local FruitDealer = workspace.IgnoreList.Int.NPCs.Shops["Foosha Village"]["Fruit Dealer (Foosha Village)"]
    if FruitDealer and FruitDealer.PrimaryPart then
        -- Verifica a posição do NPC
        local npcPosition = FruitDealer.PrimaryPart.Position
        local player = game.Players.LocalPlayer
        local character = player.Character

        -- Caso o jogador esteja distante do NPC, teleporta o jogador até o NPC
        if character and character:FindFirstChild("HumanoidRootPart") then
            local distance = (npcPosition - character.HumanoidRootPart.Position).Magnitude
            if distance > 10 then
                -- Teleporta o jogador para perto do NPC, para garantir que a interação funcione
                local targetCFrame = FruitDealer.PrimaryPart.CFrame * CFrame.new(0, 0, 3)
                tepe(targetCFrame)
                task.wait(2) -- Espera um pouco para garantir que o jogador tenha chego
            end
        end

        -- Agora vamos simular um clique na posição do NPC
        local success, result = pcall(function()
            DialogueEvent:FireServer("TalkToNpc", {
                ["NpcName"] = "Fruit Dealer (Foosha Village)"
            })
        end)

        if success then
            print("Interação com o NPC foi iniciada!")
        else
            warn("Falha ao tentar interagir com o NPC.")
        end
    else
        warn("Fruit Dealer não encontrado!")
    end
end



Tabs.Misc:AddSection("Vendedor de Frutas")
Tabs.Misc:AddToggle("Vendedor de Frutas", {
    Title = "Ir Ate o Vendedor de Fruta",
    Default = false,
    Callback = function(Value)
        if Value then
            -- Se o toggle estiver ativado, tenta interagir com o NPC
            clicarParaFalarComNPC()
        else
            -- Caso contrário, nada acontece (opcional)
            print("Interação com NPC desativada.")
        end
    end
})


-- Função para interagir automaticamente com o NPC "Aura Teacher"
local function clicarParaFalarComAuraTeacher()
    local AuraTeacher = workspace.IgnoreList.Int.NPCs.Shops["Frost Island"]["Aura Teacher"]
    if AuraTeacher and AuraTeacher.PrimaryPart then
        -- Verifica a posição do NPC
        local npcPosition = AuraTeacher.PrimaryPart.Position
        local player = game.Players.LocalPlayer
        local character = player.Character

        -- Caso o jogador esteja distante do NPC, teleporta o jogador até o NPC
        if character and character:FindFirstChild("HumanoidRootPart") then
            local distance = (npcPosition - character.HumanoidRootPart.Position).Magnitude
            if distance > 10 then
                -- Teleporta o jogador para perto do NPC, para garantir que a interação funcione
                local targetCFrame = AuraTeacher.PrimaryPart.CFrame * CFrame.new(0, 0, 3)
                tepe(targetCFrame)
                task.wait(2) -- Espera um pouco para garantir que o jogador tenha chegado
            end
        end

        -- Agora vamos simular um clique na posição do NPC
        local success, result = pcall(function()
            DialogueEvent:FireServer("TalkToNpc", {
                ["NpcName"] = "Aura Teacher"
            })
        end)

        if success then
            print("Interação com o Aura Teacher foi iniciada!")
        else
            warn("Falha ao tentar interagir com o Aura Teacher.")
        end
    else
        warn("Aura Teacher não encontrado!")
    end
end

-- Adicionando o Toggle para a interação automática com o NPC "Aura Teacher"
Tabs.Misc:AddSection("Vendedor de Haki de Armamento")
Tabs.Misc:AddToggle("TP  Vendedor de Haki de Armamento", {
    Title = "TP  Vendedor de Haki de Armamento",
    Default = false,
    Callback = function(Value)
        if Value then
            -- Se o toggle estiver ativado, tenta interagir com o NPC
            clicarParaFalarComAuraTeacher()
        else
            -- Caso contrário, nada acontece (opcional)
            print("Interação com o Aura Teacher desativada.")
        end
    end
})

-- Função para interagir automaticamente com o NPC "Dark Step Teacher"
local function clicarParaFalarComDarkStepTeacher()
    local DarkStepTeacher = workspace.IgnoreList.Int.NPCs.Shops["Orange Town"]["Dark Step Teacher"]
    if DarkStepTeacher and DarkStepTeacher.PrimaryPart then
        -- Verifica a posição do NPC
        local npcPosition = DarkStepTeacher.PrimaryPart.Position
        local player = game.Players.LocalPlayer
        local character = player.Character

        -- Caso o jogador esteja distante do NPC, teleporta o jogador até o NPC
        if character and character:FindFirstChild("HumanoidRootPart") then
            local distance = (npcPosition - character.HumanoidRootPart.Position).Magnitude
            if distance > 10 then
                -- Teleporta o jogador para perto do NPC, para garantir que a interação funcione
                local targetCFrame = DarkStepTeacher.PrimaryPart.CFrame * CFrame.new(0, 0, 3)
                tepe(targetCFrame)
                task.wait(2) -- Espera um pouco para garantir que o jogador tenha chegado
            end
        end

        -- Agora vamos simular um clique na posição do NPC
        local success, result = pcall(function()
            DialogueEvent:FireServer("TalkToNpc", {
                ["NpcName"] = "Dark Step Teacher"
            })
        end)

        if success then
            print("Interação com o Dark Step Teacher foi iniciada!")
        else
            warn("Falha ao tentar interagir com o Dark Step Teacher.")
        end
    else
        warn("Dark Step Teacher não encontrado!")
    end
end

-- Adicionando o Toggle para a interação automática com o NPC "Dark Step Teacher"
Tabs.Misc:AddSection("Vendedor do DarkStep")
Tabs.Misc:AddToggle("TP Vendedor do DarkStep", {
    Title = "TP Vendedor do DarkStep",
    Default = false,
    Callback = function(Value)
        if Value then
            -- Se o toggle estiver ativado, tenta interagir com o NPC
            clicarParaFalarComDarkStepTeacher()
        else
            -- Caso contrário, nada acontece (opcional)
            print("Interação com o Dark Step Teacher desativada.")
        end
    end
})

-- Função de teleporte
local function tepe(TargetCFrame)
    local Player = game.Players.LocalPlayer
    local Character = Player.Character
    if not Character or not Character.PrimaryPart then return false end
    if (tick() - lastTeleport) <= 0.3 and lastCFrame == TargetCFrame then return false end

    lastTeleport = tick()
    lastCFrame = TargetCFrame

    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    if HumanoidRootPart then
        HumanoidRootPart.CanCollide = false
        HumanoidRootPart.CFrame = TargetCFrame
        task.wait(0.1)
        HumanoidRootPart.CanCollide = true
        return true
    end

    return false
end

-- Função de interação com o NPC "Water Kung-Fu Teacher"
local function interagirComWaterKungFuTeacher()
    local NPC = workspace.IgnoreList.Int.NPCs.Shops["Sharkman Park"]["Water Kung-Fu Teacher"]
    if NPC and NPC.PrimaryPart then
        local npcPos = NPC.PrimaryPart.Position
        local Player = game.Players.LocalPlayer
        local Character = Player.Character
        local distance = (npcPos - Character.HumanoidRootPart.Position).Magnitude

        if distance > 10 then
            tepe(NPC.PrimaryPart.CFrame * CFrame.new(0, 0, 3))
            task.wait(2)
        end

        DialogueEvent:FireServer("TalkToNpc", {["NpcName"] = "Water Kung-Fu Teacher"})
    end
end

-- Toggle para interagir com o NPC
Tabs.Misc:AddSection("Vendedor do Estilo de luta Water Kung-Fu")
Tabs.Misc:AddToggle("TP Water Kung-Fu Teacher", {
    Title = "TP Water Kung-Fu Teacher",
    Default = false,
    Callback = function(Value)
        if Value then interagirComWaterKungFuTeacher() end
    end
})


-- Função de teleporte
local function tepe(TargetCFrame)
    local Player = game.Players.LocalPlayer
    local Character = Player.Character
    if not Character or not Character.PrimaryPart then return false end
    if (tick() - lastTeleport) <= 0.3 and lastCFrame == TargetCFrame then return false end

    lastTeleport = tick()
    lastCFrame = TargetCFrame

    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    if HumanoidRootPart then
        HumanoidRootPart.CanCollide = false
        HumanoidRootPart.CFrame = TargetCFrame
        task.wait(0.1)
        HumanoidRootPart.CanCollide = true
        return true
    end

    return false
end

-- Função de interação com o NPC "Electric Teacher"
local function interagirComElectricTeacher()
    local NPC = workspace.IgnoreList.Int.NPCs.Shops["Skypie Upper"]["Eletric Teacher"]
    if NPC and NPC.PrimaryPart then
        local npcPos = NPC.PrimaryPart.Position
        local Player = game.Players.LocalPlayer
        local Character = Player.Character
        local distance = (npcPos - Character.HumanoidRootPart.Position).Magnitude

        if distance > 10 then
            tepe(NPC.PrimaryPart.CFrame * CFrame.new(0, 0, 3))
            task.wait(2)
        end

        DialogueEvent:FireServer("TalkToNpc", {["NpcName"] = "Eletric Teacher"})
    end
end

-- Toggle para interagir com o NPC
Tabs.Misc:AddSection("Vendedor do Estilo de luta  Electric")
Tabs.Misc:AddToggle("TP Vendedor do Estilo de luta ", {
    Title = "TP Vendedor do Estilo de luta",
    Default = false,
    Callback = function(Value)
        if Value then interagirComElectricTeacher() end
    end
})

-- Função de interação com o NPC "Instinct Teacher"
local function interagirComInstinctTeacher()
    local NPC = workspace.IgnoreList.Int.NPCs.Shops["Skypie Upper"]["Instinct Teacher"]
    if NPC and NPC.PrimaryPart then
        local npcPos = NPC.PrimaryPart.Position
        local Player = game.Players.LocalPlayer
        local Character = Player.Character
        local distance = (npcPos - Character.HumanoidRootPart.Position).Magnitude

        if distance > 10 then
            tepe(NPC.PrimaryPart.CFrame * CFrame.new(0, 0, 3))
            task.wait(2)
        end

        DialogueEvent:FireServer("TalkToNpc", {["NpcName"] = "Instinct Teacher"})
    end
end

-- Toggle para interagir com o NPC
Tabs.Misc:AddSection("Vendedor do Haki da Visao")
Tabs.Misc:AddToggle("TP Vendedor do Haki da Visao", {
    Title = "TP Vendedor do Haki da Visao",
    Default = false,
    Callback = function(Value)
        if Value then interagirComInstinctTeacher() end
    end
})

Tabs.Server:AddSection("Server Options")

Tabs.Server:AddToggle("Auto Hop Server", {
    Title = "Auto Hop Server",
    Default = false,
    Callback = function(value)
        if value then
            -- Função para fazer o hop de servidor
            local function hopToNewServer()
                local TeleportService = game:GetService("TeleportService")
                local HttpService = game:GetService("HttpService")
                
                -- Tentar encontrar um servidor com vaga
                local success, servers = pcall(function()
                    local response = HttpService:JSONDecode(game:HttpGetAsync(
                        "https://games.roblox.com/v1/games/"..game.PlaceId.."/servers/Public?sortOrder=Asc&limit=100"
                    ))
                    return response.data
                end)
                
                if success and servers then
                    local availableServers = {}
                    for _, server in ipairs(servers) do
                        if server.playing < server.maxPlayers and server.id ~= game.JobId then
                            table.insert(availableServers, server.id)
                        end
                    end
                    
                    if #availableServers > 0 then
                        local randomServer = availableServers[math.random(1, #availableServers)]
                        TeleportService:TeleportToPlaceInstance(game.PlaceId, randomServer)
                    else
                        TeleportService:Teleport(game.PlaceId)
                    end
                else
                    TeleportService:Teleport(game.PlaceId)
                end
            end
            
            -- Executa o hop imediatamente quando ativado
            hopToNewServer()
            
            -- Conecta para continuar hopping enquanto o toggle estiver ativo
            spawn(function()
                while wait(5) and _ENV.AutoHopEnabled do
                    hopToNewServer()
                end
            end)
        else
            -- Desativa o auto hop
            _ENV.AutoHopEnabled = false
        end
    end
})




-- Adiciona a seção de Auto Skills
Tabs.Main:AddSection("Auto Skills")

-- Cria o dropdown para seleção de teclas
local skillKeysDropdown = Tabs.Main:AddDropdown("SkillKeysDropdown", {
    Title = "Selecionar Teclas para Auto Skills",
    Values = {"Z", "X", "C", "V", "B"},
    Multi = true,
    Default = {"Z", "X"},
    Callback = function(selectedKeys)
        _ENV.SelectedSkillKeys = selectedKeys
    end
})

-- Toggle para ativar/desativar o Auto Skills
Tabs.Main:AddToggle("AutoSkillsToggle", {
    Title = "Ativar Auto Skills",
    Default = false,
    Callback = function(value)
        _ENV.AutoSkillsEnabled = value
        
        if value then
            -- Função otimizada para pressionar as teclas
            local function pressSelectedKeys()
                local selectedKeys = _ENV.SelectedSkillKeys or {"Z", "X"}
                local virtualInput = game:GetService("VirtualInputManager")
                local keyPriority = {
                    Z = 1,
                    X = 2,
                    C = 3,
                    V = 4,
                    B = 5
                }
                
                -- Ordena as teclas por prioridade
                table.sort(selectedKeys, function(a, b)
                    return keyPriority[a] < keyPriority[b]
                end)
                
                -- Pressão mais robusta das teclas
                for _, key in ipairs(selectedKeys) do
                    local keyCode = Enum.KeyCode[key]
                    
                    -- Pressão mais longa para teclas C, V, B
                    local pressDuration = (key == "C" or key == "V" or key == "B") and 0.15 or 0.1
                    
                    virtualInput:SendKeyEvent(true, keyCode, false, nil)
                    task.wait(pressDuration)
                    virtualInput:SendKeyEvent(false, keyCode, false, nil)
                    
                    -- Intervalo maior após teclas especiais
                    local waitTime = (key == "C" or key == "V" or key == "B") and 0.3 or 0.2
                    task.wait(waitTime)
                end
            end
            
            -- Sistema de verificação de skills
            local function skillsAvailable()
                -- Verifica PC
                local pcFrame = Player.PlayerGui:FindFirstChild("MainUI")
                pcFrame = pcFrame and pcFrame:FindFirstChild("SkillsFrame")
                
                -- Verifica Mobile
                local mobileFrame = Player.PlayerGui:FindFirstChild("MobileGui")
                mobileFrame = mobileFrame and mobileFrame:FindFirstChild("SkillsFrameMobile")
                
                return (pcFrame and pcFrame.Visible) or (mobileFrame and mobileFrame.Visible)
            end
            
            -- Loop principal otimizado
            spawn(function()
                while _ENV.AutoSkillsEnabled do
                    if skillsAvailable() then
                        -- Executa 2 ciclos rápidos para garantir ativação
                        for i = 1, 2 do
                            pressSelectedKeys()
                            task.wait(0.1)
                        end
                    end
                    task.wait(0.4) -- Intervalo entre ciclos
                end
            end)
        end
    end
})


SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({})
InterfaceManager:BuildInterfaceSection(Tabs.SettingsTab)
SaveManager:BuildConfigSection(Tabs.SettingsTab)
Window:SelectTab(1)
